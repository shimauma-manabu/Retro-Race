import unittest
import pygame
from src.car import Car, CAR_WIDTH, CAR_HEIGHT # Assuming src is in PYTHONPATH
from src.track import Track # Assuming src is in PYTHONPATH

class TestCollisionLogic(unittest.TestCase):

    # @classmethod
    # def setUpClass(cls):
    #     # pygame.init() # Initialize Pygame once for all tests # TRYING WITHOUT THIS
    #     pass

    def setUp(self):
        """Set up for each test method."""
        self.car = Car(start_x=50, start_y=50)

        # Sample track points for creating a Track instance
        # This track is a simple square for easy reasoning about checkpoints
        self.track_points = [(0, 0), (200, 0), (200, 200), (0, 200)]
        self.game_track = Track(points=self.track_points, checkpoint_size=20)

        # A specific checkpoint rect for direct collision testing
        # Let's use the first checkpoint generated by our sample track
        if self.game_track.checkpoints:
            self.sample_checkpoint_rect = self.game_track.checkpoints[0]
        else:
            # Fallback if checkpoint creation failed or track has no points
            self.sample_checkpoint_rect = pygame.Rect(10, 10, 20, 20)


        # Boundary for the car's internal out-of-bounds check.
        # This refers to the car's own `check_collision` method, which uses a hardcoded area.
        # The car's `check_collision` is:
        # if not (0 < self.x < 800 and 0 < self.y < 600): return True
        self.car_hardcoded_boundary_x_min = 0
        self.car_hardcoded_boundary_x_max = 800
        self.car_hardcoded_boundary_y_min = 0
        self.car_hardcoded_boundary_y_max = 600


    def test_car_internal_collision_logic_inside_bounds(self):
        """Test car is NOT colliding when within its hardcoded game area."""
        self.car.x = self.car_hardcoded_boundary_x_max / 2
        self.car.y = self.car_hardcoded_boundary_y_max / 2
        self.car.update_position() # Updates rect
        # The Car's check_collision takes a Track object, but its current logic
        # only checks x,y against hardcoded 0-800, 0-600.
        # Passing `None` might cause issues if the method tries to access track.points etc.
        # For this specific test, we only care about the x,y boundary check.
        # A mock track or a minimal track object might be better.
        # Let's use the game_track created, assuming it won't interfere with the simple boundary check.
        self.assertFalse(self.car.check_collision(self.game_track), "Car should be inside bounds.")

    def test_car_internal_collision_logic_outside_bounds_x_too_low(self):
        """Test car IS colliding when x is too low (outside hardcoded game area)."""
        self.car.x = self.car_hardcoded_boundary_x_min - 10 # Outside
        self.car.y = self.car_hardcoded_boundary_y_max / 2
        self.car.update_position()
        self.assertTrue(self.car.check_collision(self.game_track), "Car should be outside bounds (x too low).")

    def test_car_internal_collision_logic_outside_bounds_x_too_high(self):
        self.car.x = self.car_hardcoded_boundary_x_max + 10 # Outside
        self.car.y = self.car_hardcoded_boundary_y_max / 2
        self.car.update_position()
        self.assertTrue(self.car.check_collision(self.game_track), "Car should be outside bounds (x too high).")

    def test_car_internal_collision_logic_outside_bounds_y_too_low(self):
        self.car.x = self.car_hardcoded_boundary_x_max / 2
        self.car.y = self.car_hardcoded_boundary_y_min - 10 # Outside
        self.car.update_position()
        self.assertTrue(self.car.check_collision(self.game_track), "Car should be outside bounds (y too low).")

    def test_car_internal_collision_logic_outside_bounds_y_too_high(self):
        self.car.x = self.car_hardcoded_boundary_x_max / 2
        self.car.y = self.car_hardcoded_boundary_y_max + 10 # Outside
        self.car.update_position()
        self.assertTrue(self.car.check_collision(self.game_track), "Car should be outside bounds (y too high).")

    def test_checkpoint_collision_hit(self):
        """Test direct rect collision when car overlaps a checkpoint."""
        # Position car directly on the sample_checkpoint_rect
        self.car.x = self.sample_checkpoint_rect.centerx
        self.car.y = self.sample_checkpoint_rect.centery
        self.car.update_position() # This updates self.car.rect
        self.assertTrue(self.car.rect.colliderect(self.sample_checkpoint_rect), "Car rect should collide with checkpoint rect.")

    def test_checkpoint_collision_miss(self):
        """Test direct rect collision when car does not overlap a checkpoint."""
        # Position car far away from the sample_checkpoint_rect
        self.car.x = self.sample_checkpoint_rect.centerx + CAR_WIDTH + self.sample_checkpoint_rect.width + 100
        self.car.y = self.sample_checkpoint_rect.centery + CAR_HEIGHT + self.sample_checkpoint_rect.height + 100
        self.car.update_position() # This updates self.car.rect
        self.assertFalse(self.car.rect.colliderect(self.sample_checkpoint_rect), "Car rect should NOT collide with checkpoint rect.")

    def test_track_get_checkpoint_valid_index(self):
        """Test retrieving a valid checkpoint from track."""
        cp = self.game_track.get_checkpoint(0)
        self.assertIsNotNone(cp)
        self.assertIsInstance(cp, pygame.Rect)

    def test_track_get_checkpoint_invalid_index_high(self):
        """Test retrieving an invalid checkpoint (index too high)."""
        cp = self.game_track.get_checkpoint(len(self.game_track.checkpoints) + 5)
        self.assertIsNone(cp)

    def test_track_get_checkpoint_invalid_index_negative(self):
        """Test retrieving an invalid checkpoint (negative index)."""
        cp = self.game_track.get_checkpoint(-1)
        self.assertIsNone(cp)

if __name__ == '__main__':
    unittest.main()
